# Code Review: review-feature-branch vs Main

**Date**: 2025-12-09T18:42:16Z
**Reviewer**: Branch Code Reviewer Agent
**Branch**: review-feature-branch
**Base**: main
**Files Changed**: 60
**Lines Added/Removed**: +2526 / -136

**Key Commits Reviewed**:
- `311f291` Querying a room with as an aggregate
- `480a2c4` Let's create an Adventure with some rooms
- `ec2b4e8` Persist UUIDs

---

## Executive Summary

This branch introduces significant new functionality to the D&D Kotlin project:
- **New modules**: `cli` (Kotter-based terminal UI), `tool` (Clikt command-line tools), `persistence` (MongoDB integration)
- **Core domain**: Adventure/Room aggregates with WorldBuilder, SaveGame system, Narrator queries
- **Architectural pattern**: Implements Hexagonal Architecture with CQRS as defined in `docs/decisions.md`

**Overall Quality**: The implementation demonstrates good understanding of DDD patterns and Kotlin idioms, but contains **3 critical bugs** that would prevent the system from working correctly. Several architectural decisions also deviate from the documented standards.

**Merge Recommendation**: **DO NOT MERGE** until critical issues are resolved.

---

## Critical Issues

### 1. BROKEN ADVENTURE INITIALIZATION (CRITICAL BUG)
**File**: `/tool/src/main/kotlin/tool/commands/CreateAdventureCommand.kt:58`
**Severity**: CRITICAL

```kotlin
val adventure = Adventure(
    id = Id.fromString("8b4dc8c3-c3d5-4484-8d4e-0b7fe85bafd4"),
    name = "New Adventure",
    initialRoomId = Id.fromString("c5b563b7-d4c6-40da-b4ac-d9d081ac0f34"), // ❌ BUG
    rooms = world.rooms,
)
```

**Problem**: The `initialRoomId` UUID `c5b563b7-d4c6-40da-b4ac-d9d081ac0f34` does not exist in the `world.rooms` list. The WorldBuilder creates rooms with IDs:
- `ae894d71-b501-42fd-b1a3-213e2e82f79c` (Starting Room)
- `5a06b938-4e0c-4a8b-b2e4-94167417b395` (Hallway)
- `4bfb93d0-a064-4c1b-993e-8211639569d5` (Treasure Room)

**Impact**: Starting a game with this adventure will fail when the system tries to place the player in a non-existent room.

**Fix**: Use an actual room ID:
```kotlin
initialRoomId = Id.fromString("ae894d71-b501-42fd-b1a3-213e2e82f79c"), // Starting Room
```

---

### 2. UNIMPLEMENTED SAVE METHOD (CRITICAL BUG)
**File**: `/dungeons-domain/src/main/kotlin/domain/adventure/MockAdventureRepository.kt:32`
**Severity**: CRITICAL

```kotlin
override fun save(entity: Adventure): Adventure? {
    TODO("Not yet implemented")
}
```

**Problem**: The `save()` method throws `NotImplementedError` at runtime, but `CreateAdventureCommand` calls this method in production code (line 61).

**Impact**: Running `create-adventure` command will crash with `kotlin.NotImplementedError`.

**Architectural Issue**: Mock implementations belong in test sources (`src/test/kotlin`), not production (`src/main/kotlin`). Spring component scanning will pick this up and potentially inject it instead of the MongoDB implementation.

**Fix**:
1. Move `MockAdventureRepository` to `src/test/kotlin`
2. Use `@Profile("test")` annotation if it must remain in main sources
3. Implement the save method for the mock

---

### 3. DUPLICATE GAMESTATE CLASSES (CRITICAL DESIGN FLAW)
**Severity**: CRITICAL
**Files**:
- `/cli/src/main/kotlin/cli/GameState.kt:11`
- `/dungeons-domain/src/main/kotlin/domain/world/Room.kt:23`

**Problem**: Two completely different classes both named `GameState`:

```kotlin
// cli module
data class GameState(var player: Player? = null, var currentGameId: Id<SaveGame>? = null)

// domain module
data class GameState(val id: Id<GameState>, val worldId: Id<World>, val currentRoom: Id<Room>)
```

**Impact**:
- Extremely confusing for developers
- Potential for import errors and wrong class usage
- Violates DRY and single source of truth

**Fix**: Rename one or both classes to clearly distinguish their purposes:
- CLI: `CliSessionState` or `ClientGameState`
- Domain: `SavedGameState` or `GameStateSnapshot`

Alternatively, consolidate if they represent the same concept.

---

### 4. HEXAGONAL ARCHITECTURE VIOLATION
**File**: `/dungeons-domain/src/main/kotlin/domain/savegame/NewGameUseCase.kt:13`
**Severity**: HIGH
**Per**: `docs/decisions.md` - Hexagonal Architecture

```kotlin
fun execute(userId: UUID, adventure: Adventure): Id<SaveGame>
```

**Problem**: Domain UseCase accepts `java.util.UUID` (infrastructure type) instead of domain type `Id<User>`.

**Why This Matters**: According to `docs/decisions.md`, the domain layer should be infrastructure-agnostic. Using Java's UUID directly couples the domain to Java stdlib implementation details.

**Fix**:
```kotlin
fun execute(userId: Id<User>, adventure: Adventure): Id<SaveGame>
```

Callers should convert to `Id<User>` before calling the use case.

---

### 5. REPOSITORY RETURNS JAVA OPTIONAL
**File**: `/dungeons-domain/src/main/kotlin/domain/adventure/AdventureRepository.kt`
**Severity**: MEDIUM-HIGH
**Per**: `docs/decisions.md` - Domain should be infrastructure-agnostic

**Problem**: Repository interface returns `Optional<Adventure>` (Java type) instead of idiomatic Kotlin nullable `Adventure?`.

**Evidence**: Line 21 of `NarrateRoomQuery.kt` must call `.getOrNull()` to unwrap:
```kotlin
val adventure: Adventure? = adventureRepository.findById(saveGame.adventureId).getOrNull()
```

**Fix**: Change repository interface to:
```kotlin
fun findById(id: Id<Adventure>): Adventure?
```

This is more idiomatic Kotlin and keeps Java types out of domain contracts.

---

## Kotlin Idioms Analysis

### Positive Observations

1. **Excellent use of inline value classes**: `Id<T>` uses `@JvmInline value class` for type-safe, zero-overhead wrappers
2. **Proper data classes**: DTOs (`GameIdResponse`, `WorldIdResponse`, `Adventure`, `Room`) correctly use data classes
3. **Extension functions**: `Session.clearScreen()` is a nice idiomatic extension
4. **Scope functions**: Good use of `let`, `require`, and null-safe operators
5. **Companion object for factory methods**: `Id.generate()`, `Id.fromString()` - excellent pattern

### Issues Found

#### MEDIUM: Immutability Violations

**File**: `/cli/src/main/kotlin/cli/GameState.kt:10-11`

```kotlin
@Suppress("DataClassContainsFunctions", "DataClassShouldBeImmutable")
data class GameState(var player: Player? = null, var currentGameId: Id<SaveGame>? = null)
```

**Issue**: Using `var` in data class defeats the purpose of data classes. The suppressions indicate a code smell - you're fighting the language.

**Evidence**: The code already uses `.copy()` properly (line 81-83 of `PickAdventureScreen.kt`):
```kotlin
val newGameState = gameStateHolder.gameState.copy(
    currentGameId = gameId,
)
```

**Fix**: Make properties `val`:
```kotlin
data class GameState(val player: Player? = null, val currentGameId: Id<SaveGame>? = null)
```

---

#### MEDIUM: Typos in Class Names

**File**: `/dungeons-domain/src/main/kotlin/domain/world/Room.kt:44`

```kotlin
data class WordCoord(val x: Int, val y: Int)  // ❌ Should be WorldCoord or RoomCoord
```

**File**: `/cli/src/main/kotlin/cli/screen/PickAdventureScreen.kt:33`

```kotlin
private lateinit var selectedAvdenture: LiveVar<Int>  // ❌ Should be selectedAdventure
```

**Impact**: Reduces code clarity and professionalism.

---

#### MEDIUM: Inappropriate Use of `lateinit`

**Files**:
- `/cli/src/main/kotlin/cli/screen/PickAdventureScreen.kt:30-33`
- `/cli/src/main/kotlin/cli/screen/RoomScreen.kt:23`

```kotlin
@Suppress("LateinitUsage")
private lateinit var adventures: LiveList<Adventure>
```

**Issue**: Using `lateinit` with a suppression warning indicates architectural issues. The fact that you need to suppress suggests the design is fighting Kotlin's safety.

**Better Approaches**:
1. Use nullable types: `private var adventures: LiveList<Adventure>? = null`
2. Initialize in constructor/dependency injection
3. Redesign initialization flow using delegation

---

#### LOW: Unnecessary Collection Operations

**File**: `/dungeons-domain/src/main/kotlin/domain/world/Room.kt:68`

```kotlin
.mapNotNull { (direction, coord) ->
    rooms[coord]?.let { adjacentRoom -> direction to adjacentRoom.id }
}
.associate { it }  // ❌ Unnecessary
```

**Better**:
```kotlin
.mapNotNull { (direction, coord) ->
    rooms[coord]?.let { adjacentRoom -> direction to adjacentRoom.id }
}
.toMap()
```

---

#### LOW: Dead/Debug Code

**File**: `/dungeons-domain/src/main/kotlin/domain/world/Room.kt:25-42`

Top-level function `createWorld()` with `println` statements appears to be unused debug code.

**Recommendation**: Delete or move to examples/tests.

**File**: `/cli/src/main/kotlin/cli/CliApplication.kt`

Entire file appears to be commented-out/experimental code.

**Recommendation**: Delete if not needed.

---

#### LOW: Inconsistent Logging

**File**: `/dungeons-domain/src/main/kotlin/domain/savegame/NewGameUseCase.kt:7`

```kotlin
import java.util.logging.Logger.getLogger
```

**Issue**: Uses `java.util.logging` while rest of codebase uses SLF4J.

**Fix**: Standardize on SLF4J:
```kotlin
import org.slf4j.LoggerFactory

private val logger = LoggerFactory.getLogger(NewGameUseCase::class.java)
```

---

#### LOW: Commented Code

**File**: `/tool/src/main/kotlin/tool/commands/CreateAdventureCommand.kt:20-27`

```kotlin
// -- ae894d71-b501-42fd-b1a3-213e2e82f79c
// -- 5a06b938-4e0c-4a8b-b2e4-94167417b395
// 4bfb93d0-a064-4c1b-993e-8211639569d5
// ... (more UUIDs)
```

**Recommendation**: Remove commented code. If these UUIDs are important references, add a proper comment explaining their purpose.

---

## Code Quality & Bug Analysis

### HIGH PRIORITY

#### Misuse of `require()` for Business Logic

**Files**:
- `/dungeons-domain/src/main/kotlin/domain/narrator/NarrateRoomQuery.kt:18-22`
- `/cli/src/main/kotlin/cli/screen/PickAdventureScreen.kt:76-77`
- `/cli/src/main/kotlin/cli/screen/RoomScreen.kt:44-45`

```kotlin
val saveGame = saveGameRepository.findByUserId(userId, saveGameId)
require(saveGame != null) { "No save game found for user $userId" }

val adventure: Adventure? = adventureRepository.findById(saveGame.adventureId).getOrNull()
require(adventure != null) { "No adventure found for id ${saveGame.adventureId}" }
```

**Problem**: `require()` is for precondition checking (programming errors), not business logic validation. It throws `IllegalArgumentException` which doesn't distinguish between:
- User error (invalid saveGameId)
- System error (database corruption)

**Better Approaches**:
1. Return `null` from query and let caller handle it
2. Throw domain-specific exceptions: `SaveGameNotFoundException`, `AdventureNotFoundException`
3. Use `Result<T>` type for operations that can fail

**Current Impact**: Error handling is indistinguishable from programming bugs.

---

#### Thread-Safety Issue

**File**: `/cli/src/main/kotlin/cli/GameState.kt:15-20`

```kotlin
class GameStateHolder {
    private var _gameState: AtomicReference<GameState> = AtomicReference(GameState())

    var gameState
        get() = _gameState.get()
        set(value) = _gameState.set(value)
}
```

**Problem**: Using `AtomicReference` suggests thread-safety concerns, but the getter/setter pattern is NOT thread-safe.

**Race Condition**:
```kotlin
// Thread 1
val state = holder.gameState  // reads X
// Thread 2 modifies state
holder.gameState = modifiedState  // writes Y
// Thread 1 continues with stale X
holder.gameState = state.copy(player = newPlayer)  // overwrites Y with stale data
```

**Fix Options**:
1. If single-threaded (likely for CLI): Remove `AtomicReference`, use plain `var`
2. If multi-threaded: Use proper synchronization or `AtomicReference.updateAndGet()`

---

#### Incomplete Test Coverage

**File**: `/dungeons-domain/src/test/kotlin/domain/world/WorldBuilderTest.kt`

**Issue**: Only one test case covering the happy path (3 connected rooms).

**Missing Coverage**:
- Empty world (no rooms)
- Single room (no connections)
- Non-contiguous rooms (isolated islands)
- Large grids
- Negative coordinates
- Duplicate coordinates (overwrite behavior)

**Recommendation**: Add edge case tests before merging.

---

### MEDIUM PRIORITY

#### Placeholder Implementations

**File**: `/app/src/main/kotlin/app/rest/GameController.kt:10`

```kotlin
fun createGame(): GameIdResponse = GameIdResponse("game-id-placeholder")
```

**Question**: Is this intentional WIP or should it be implemented?

**File**: `/app/src/main/kotlin/app/rest/WorldController.kt:16`

```kotlin
return WorldIdResponse("world-id-placeholder")
```

**Recommendation**: Either implement or document as TODO.

---

#### JVM System Property Side Effect

**File**: `/cli/src/main/kotlin/cli/KotterCli.kt:82`

```kotlin
System.setProperty("java.awt.headless", "false")
```

**Issue**: Sets JVM-wide property in main function with no comment explaining why.

**Recommendation**: Add comment explaining this is required for VirtualTerminal on some systems (based on the code comment on line 81).

---

### LOW PRIORITY

#### Redundant Interface Inheritance

**File**: `/persistence/src/main/kotlin/persistence/mongodb/MongoDBAdventureRepository.kt`

```kotlin
interface MongoDBAdventureRepository :
    AdventureRepository,
    MongoRepository<Adventure, Id<Adventure>>,
    CrudRepository<Adventure, Id<Adventure>>  // ❌ Redundant
```

**Note**: `MongoRepository` already extends `CrudRepository`, so explicitly listing both is redundant (but not harmful).

---

## Architecture Review

### Alignment with `docs/decisions.md`

#### ✅ POSITIVE: Hexagonal Architecture
- **Good**: Clear module separation (`dungeons-domain`, `persistence`, `cli`, `app`)
- **Good**: Domain defines repository interfaces, infrastructure implements them
- **Good**: Dependency direction is correct (adapters depend on domain, not vice versa)

#### ✅ POSITIVE: CQRS Pattern
- **Good**: Commands (`NewGameUseCase`) separated from Queries (`NarrateRoomQuery`, `ListAdventuresQuery`)
- **Good**: Clear naming convention: `*UseCase` for commands, `*Query` for queries

#### ✅ POSITIVE: Spring in Domain Layer
Per docs: "We use Spring intentionally in the domain layer to annotate Services."
- **Observation**: `@Component` annotations on UseCases and Queries
- **Assessment**: Aligns with stated architectural decision

#### ⚠️ CONCERN: Domain Objects as Entities
Per docs: "We use domain objects also as our entities in the persistence layer to avoid mapping overhead."

**Implementation**: `Adventure`, `Room` persisted directly to MongoDB

**Potential Issue**: `Id<T>` is a generic inline value class. MongoDB serialization of this type needs verification.

**Recommendation**: Add integration tests verifying MongoDB correctly serializes/deserializes `Id<T>` types.

---

### SOLID Principles Evaluation

#### ❌ Single Responsibility Principle Violation

**File**: `/dungeons-domain/src/main/kotlin/domain/world/Room.kt`

**Problem**: File contains 7 different classes/concerns:
1. `Direction` enum
2. `Room` data class
3. `World` class
4. `GameState` data class (unrelated to Room/World)
5. `createWorld()` function (debug code)
6. `WordCoord` class
7. `WorldBuilder` class

**Impact**: Poor cohesion, violates SRP

**Recommendation**: Split into separate files:
- `Direction.kt`
- `Room.kt`
- `World.kt`
- Move `GameState` to `domain.savegame` (or delete if duplicate)
- Delete `createWorld()` or move to examples
- `Coordinate.kt` (and fix typo to `WorldCoord` or `RoomCoord`)
- `WorldBuilder.kt`

---

#### ⚠️ Interface Segregation Principle

**File**: `/dungeons-domain/src/main/kotlin/domain/adventure/AdventureRepository.kt`

**Issue**: Single repository interface with both read and write methods forces `MockAdventureRepository` to implement `save()` even though it doesn't need it (hence the `TODO`).

**Better Design**: Separate interfaces
```kotlin
interface AdventureReader {
    fun findAll(): List<Adventure>
    fun findById(id: Id<Adventure>): Adventure?
}

interface AdventureWriter {
    fun save(entity: Adventure): Adventure
}

interface AdventureRepository : AdventureReader, AdventureWriter
```

This allows mocks to implement only what they need.

---

#### ⚠️ Open/Closed Principle

**File**: `/cli/src/main/kotlin/cli/KotterCli.kt:35-43`

```kotlin
fun screens(...): ScreenMap {
    return listOf(
        myScreen,
        detailsScreen,
        pickAdventureScreen,
        roomScreen,
    ).associateBy { it.ownTransition }
}
```

**Good**: This design allows adding new screens without modifying existing code (open for extension, closed for modification).

---

### Domain-Driven Design Assessment

#### ✅ Aggregate Pattern (Mostly Correct)

**Evidence**: Commit message "311f291 Querying a room with as an aggregate"

**File**: `/persistence/src/main/kotlin/persistence/mongodb/MongoDBRoomRepository.kt`

```kotlin
val aggregation = Aggregation.newAggregation(
    match(Criteria.where("_id").isEqualTo(adventureId.value)),
    project("rooms"),
    unwind("rooms"),
    match(Criteria.where("rooms._id").isEqualTo(roomId.value)),
    replaceRoot("rooms")
)
```

**Analysis**:
- **Good**: `Adventure` is treated as an aggregate root containing `Room` entities
- **Good**: MongoDB aggregation properly queries nested rooms
- **Concern**: `RoomRepository.find(adventureId, roomId)` exposes ability to query individual rooms outside the aggregate root
- **Question**: Should rooms only be accessible through `Adventure`?

**DDD Purist View**: Rooms should not have their own repository; they should only be accessed via `Adventure.getRoomById()`

**Pragmatic View**: For read operations (queries), bypassing the aggregate for performance is acceptable

**Recommendation**: Document the decision. If breaking aggregate boundaries, explain why (e.g., query performance).

---

### Dependency Management

#### ⚠️ Build Configuration Workaround

**File**: `/buildSrc/src/main/kotlin/buildlogic.kotlin-library-conventions.gradle.kts`

```kotlin
plugins {
    id("buildlogic.kotlin-common-conventions")
    id("org.springframework.boot")  // ⚠️ Applied to library modules
    `java-library`
}

tasks.getByName<BootJar>("bootJar") {
    enabled = false  // ⚠️ Immediately disabled
}

tasks.getByName<Jar>("jar") {
    enabled = true
}
```

**Issue**: Applies Spring Boot plugin to ALL library modules, then immediately disables the bootJar task.

**Per docs/decisions.md**: "every module needs to be a spring boot gradle project"

**Assessment**: This seems like a workaround for dependency management. Typically, libraries should use `io.spring.dependency-management` plugin, not the full Spring Boot plugin.

**Recommendation**:
1. Clarify in docs WHY all modules need Spring Boot plugin
2. Consider if `io.spring.dependency-management` alone would suffice for libraries

---

### Module Architecture

```
dungeons-kotlin/
├── app/              # REST API (driving adapter)
├── cli/              # Terminal UI (driving adapter) [NEW]
├── tool/             # CLI commands (driving adapter) [NEW]
├── dungeons-domain/  # Core domain logic
├── persistence/      # MongoDB adapter (driven adapter) [NEW]
└── buildSrc/         # Build configuration
```

**Assessment**: Clear separation of concerns, proper hexagonal architecture.

---

## Recommendations

### MUST FIX (Before Merge)

1. **Fix initialRoomId bug** in `CreateAdventureCommand.kt` - use actual room ID
2. **Implement or remove** `MockAdventureRepository.save()` - move mock to test sources
3. **Resolve GameState duplication** - rename or consolidate the two `GameState` classes
4. **Fix NewGameUseCase signature** - use `Id<User>` instead of `UUID`
5. **Change AdventureRepository** to return `Adventure?` instead of `Optional<Adventure>`

### SHOULD FIX (High Priority)

6. **Replace `require()` with proper error handling** in queries - use domain exceptions or Result types
7. **Fix thread-safety** in `GameStateHolder` - remove AtomicReference or use proper synchronization
8. **Fix typos**: `WordCoord` → `WorldCoord`, `selectedAvdenture` → `selectedAdventure`
9. **Make GameState immutable** - change `var` to `val`
10. **Split Room.kt** - one class per file following SRP

### RECOMMENDED (Medium Priority)

11. **Add test coverage** for WorldBuilder edge cases
12. **Standardize logging** - use SLF4J throughout
13. **Remove dead code** - `createWorld()` function, commented UUIDs, `CliApplication.kt`
14. **Document JVM property** - add comment explaining `java.awt.headless = false`
15. **Consider Interface Segregation** - split AdventureRepository into read/write interfaces

### CONSIDER (Low Priority)

16. **Add MongoDB serialization tests** for `Id<T>` inline value class
17. **Document aggregate boundary decision** - why RoomRepository exists despite Adventure being aggregate root
18. **Review build configuration** - clarify why Spring Boot plugin is needed on library modules
19. **Add component scanning restrictions** - prevent `MockAdventureRepository` from being picked up
20. **Add trailing commas** to multi-line collections (Kotlin convention)

---

## Positive Observations

1. **Strong architectural foundation**: Clear hexagonal architecture with proper dependency direction
2. **Good DDD patterns**: Aggregates, value objects (`Id<T>`), repositories, use cases
3. **Idiomatic Kotlin**: Inline value classes, data classes, extension functions, scope functions
4. **CQRS separation**: Clear distinction between commands and queries
5. **Type safety**: Generic `Id<T>` prevents mixing IDs of different entity types
6. **Comprehensive change set**: Introduces significant functionality while maintaining existing patterns
7. **Spring integration**: Thoughtful use of Spring in domain layer as per architectural decisions
8. **Test coverage started**: WorldBuilderTest demonstrates TDD approach

---

## Conclusion

This branch represents a substantial addition to the D&D Kotlin project, introducing Adventure/Room domain concepts, MongoDB persistence, and two new user-facing modules (CLI and tool). The implementation demonstrates solid understanding of Hexagonal Architecture, DDD patterns, and Kotlin idioms.

However, **the branch is not ready for merge** due to:
- **3 critical bugs** that will cause runtime failures
- **2 architectural violations** of documented standards in `docs/decisions.md`
- **Multiple code quality issues** affecting maintainability

### Merge Readiness: ❌ NOT READY

**Blockers**:
1. `CreateAdventureCommand` will fail - invalid `initialRoomId`
2. `MockAdventureRepository.save()` throws `NotImplementedError`
3. Duplicate `GameState` classes cause confusion
4. Domain layer accepts non-domain types (`UUID`)
5. Repository interface uses Java `Optional` instead of Kotlin nullable

**Estimated Effort to Fix**: 2-4 hours to address critical issues, 1-2 days for all high-priority recommendations.

**Next Steps**:
1. Fix the 5 critical/high issues listed above
2. Add integration test verifying `create-adventure` command works end-to-end
3. Add test verifying MongoDB serialization of `Id<T>` types
4. Address code quality issues (typos, dead code, immutability)
5. Re-review and merge

---

## Files Requiring Changes

### Critical Priority
- `/tool/src/main/kotlin/tool/commands/CreateAdventureCommand.kt` - Fix initialRoomId
- `/dungeons-domain/src/main/kotlin/domain/adventure/MockAdventureRepository.kt` - Move to test sources
- `/dungeons-domain/src/main/kotlin/domain/world/Room.kt` - Rename duplicate GameState
- `/cli/src/main/kotlin/cli/GameState.kt` - Rename duplicate GameState
- `/dungeons-domain/src/main/kotlin/domain/savegame/NewGameUseCase.kt` - Change UUID to Id<User>
- `/dungeons-domain/src/main/kotlin/domain/adventure/AdventureRepository.kt` - Change Optional to nullable

### High Priority
- `/dungeons-domain/src/main/kotlin/domain/narrator/NarrateRoomQuery.kt` - Replace require() with proper error handling
- `/cli/src/main/kotlin/cli/GameState.kt` - Fix thread-safety and immutability
- `/cli/src/main/kotlin/cli/screen/PickAdventureScreen.kt` - Fix typo, replace require()
- `/cli/src/main/kotlin/cli/screen/RoomScreen.kt` - Replace require()
- `/dungeons-domain/src/main/kotlin/domain/world/Room.kt` - Split into separate files

---

**Review completed at**: 2025-12-09T18:42:16Z
**Reviewer**: Branch Code Reviewer Agent (Multi-perspective Analysis)
